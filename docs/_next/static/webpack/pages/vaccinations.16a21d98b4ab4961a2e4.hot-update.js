webpackHotUpdate_N_E("pages/vaccinations",{

/***/ "./src/data/getVaccineData.js":
/*!************************************!*\
  !*** ./src/data/getVaccineData.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _jsonpFetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsonpFetch */ \"./src/data/jsonpFetch.js\");\n\nvar dataUrl = 'https://data.ontario.ca/api/3/action/datastore_search?resource_id=8a89caa9-511c-4568-af89-7f2174b4378c&limit=100000';\n\nvar ensureNumber = function ensureNumber(value) {\n  if (typeof value === 'number') {\n    return value;\n  }\n\n  return Number((value || '0').replace(/,/g, ''));\n};\n\nvar getVaccineData = function getVaccineData() {\n  return new Promise(function (resolve) {\n    Object(_jsonpFetch__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(dataUrl, function (_ref) {\n      var result = _ref.result;\n      var rawRecords = result.records;\n      rawRecords.sort(function (a, b) {\n        return new Date(a.report_date) - new Date(b.report_date);\n      });\n      var vaccines_last7days = [0, 0, 0, 0, 0, 0, 0]; // Data comes in with gaps for some dates, so fill in the gaps by replicating the previous date's data\n\n      var records = [];\n\n      for (var currentRecordIndex = 1; currentRecordIndex < rawRecords.length; currentRecordIndex++) {\n        // Backfill up to, but not including, the current record\n        var currentRecord = rawRecords[currentRecordIndex];\n        var curRecordTime = new Date(currentRecord.report_date).getTime(); // Always add the previous record in the original data set\n\n        var prevRecord = rawRecords[currentRecordIndex - 1];\n        records.push(prevRecord); // Continue adding copies of the previous record, until it matches the current record\n\n        var dateToFill = new Date(prevRecord.report_date);\n        dateToFill.setDate(dateToFill.getDate() + 1);\n\n        while (dateToFill.getTime() < curRecordTime) {\n          // Create a new record with a date to fill\n          var backfillRecord = Object.assign({}, prevRecord, {\n            report_date: dateToFill.toISOString().replace(/\\.\\d+Z/, '')\n          });\n          records.push(backfillRecord); // Update the date to fill\n\n          dateToFill.setDate(dateToFill.getDate() + 1);\n        }\n      } // Add the last record, which wasn't added by the above loop\n\n\n      records.push(rawRecords[rawRecords.length - 1]); // Back to your regularly scheduled code\n\n      records.map(function (record) {\n        var report_date = record.report_date,\n            total_doses_administered = record.total_doses_administered,\n            previous_day_total_doses_administered = record.previous_day_total_doses_administered,\n            total_individuals_fully_vaccinated = record.total_individuals_fully_vaccinated;\n        record.date_string = new Date(report_date).toLocaleString('en-us', {\n          month: 'short',\n          day: 'numeric'\n        });\n        record.total_doses_administered = ensureNumber(total_doses_administered);\n        record.previous_day_total_doses_administered = ensureNumber(previous_day_total_doses_administered);\n        record.total_individuals_fully_vaccinated = ensureNumber(total_individuals_fully_vaccinated);\n        record.previous_day_third_doses = previous_day_total_doses_administered - ensureNumber(record.previous_day_at_least_one) - ensureNumber(record.previous_day_fully_vaccinated);\n        vaccines_last7days.shift();\n        vaccines_last7days.push(record.previous_day_total_doses_administered);\n        var total_vaccines_last7days = vaccines_last7days.reduce(function (total, cases) {\n          return cases + total;\n        }, 0);\n        record.new_vaccines_rolling_average = Math.round(total_vaccines_last7days / 7);\n        return record;\n      });\n      resolve(records);\n    });\n  });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (getVaccineData);\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2RhdGEvZ2V0VmFjY2luZURhdGEuanM/MDA0MCJdLCJuYW1lcyI6WyJkYXRhVXJsIiwiZW5zdXJlTnVtYmVyIiwidmFsdWUiLCJOdW1iZXIiLCJyZXBsYWNlIiwiZ2V0VmFjY2luZURhdGEiLCJQcm9taXNlIiwicmVzb2x2ZSIsImpzb25wRmV0Y2giLCJyZXN1bHQiLCJyYXdSZWNvcmRzIiwicmVjb3JkcyIsInNvcnQiLCJhIiwiYiIsIkRhdGUiLCJyZXBvcnRfZGF0ZSIsInZhY2NpbmVzX2xhc3Q3ZGF5cyIsImN1cnJlbnRSZWNvcmRJbmRleCIsImxlbmd0aCIsImN1cnJlbnRSZWNvcmQiLCJjdXJSZWNvcmRUaW1lIiwiZ2V0VGltZSIsInByZXZSZWNvcmQiLCJwdXNoIiwiZGF0ZVRvRmlsbCIsInNldERhdGUiLCJnZXREYXRlIiwiYmFja2ZpbGxSZWNvcmQiLCJPYmplY3QiLCJhc3NpZ24iLCJ0b0lTT1N0cmluZyIsIm1hcCIsInJlY29yZCIsInRvdGFsX2Rvc2VzX2FkbWluaXN0ZXJlZCIsInByZXZpb3VzX2RheV90b3RhbF9kb3Nlc19hZG1pbmlzdGVyZWQiLCJ0b3RhbF9pbmRpdmlkdWFsc19mdWxseV92YWNjaW5hdGVkIiwiZGF0ZV9zdHJpbmciLCJ0b0xvY2FsZVN0cmluZyIsIm1vbnRoIiwiZGF5IiwicHJldmlvdXNfZGF5X3RoaXJkX2Rvc2VzIiwicHJldmlvdXNfZGF5X2F0X2xlYXN0X29uZSIsInByZXZpb3VzX2RheV9mdWxseV92YWNjaW5hdGVkIiwic2hpZnQiLCJ0b3RhbF92YWNjaW5lc19sYXN0N2RheXMiLCJyZWR1Y2UiLCJ0b3RhbCIsImNhc2VzIiwibmV3X3ZhY2NpbmVzX3JvbGxpbmdfYXZlcmFnZSIsIk1hdGgiLCJyb3VuZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBRUEsSUFBTUEsT0FBTyxHQUNYLHFIQURGOztBQUdBLElBQU1DLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQUND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SUFBSixDQUFTQyxXQUFULEVBQXNCc0IsY0FBdEIsQ0FBcUMsT0FBckMsRUFBOEM7QUFDakVDLGVBQUssRUFBRSxPQUQwRDtBQUVqRUMsYUFBRyxFQUFFO0FBRjRELFNBQTlDLENBQXJCO0FBSUFQLGNBQU0sQ0FBQ0Msd0JBQVAsR0FBa0NqQyxZQUFZLENBQUNpQyx3QkFBRCxDQUE5QztBQUNBRCxjQUFNLENBQUNFLHFDQUFQLEdBQStDbEMsWUFBWSxDQUFDa0MscUNBQUQsQ0FBM0Q7QUFDQUYsY0FBTSxDQUFDRyxrQ0FBUCxHQUE0Q25DLFlBQVksQ0FBQ21DLGtDQUFELENBQXhEO0FBRUFILGNBQU0sQ0FBQ1Esd0JBQVAsR0FBa0NOLHFDQUFxQyxHQUFHbEMsWUFBWSxDQUFDZ0MsTUFBTSxDQUFDUyx5QkFBUixDQUFwRCxHQUF5RnpDLFlBQVksQ0FBQ2dDLE1BQU0sQ0FBQ1UsNkJBQVIsQ0FBdkk7QUFFQTFCLDBCQUFrQixDQUFDMkIsS0FBbkI7QUFDQTNCLDBCQUFrQixDQUFDTyxJQUFuQixDQUF3QlMsTUFBTSxDQUFDRSxxQ0FBL0I7QUFDQSxZQUFNVSx3QkFBd0IsR0FBRzVCLGtCQUFrQixDQUFDNkIsTUFBbkIsQ0FBMEIsVUFBQ0MsS0FBRCxFQUFRQyxLQUFSO0FBQUEsaUJBQWtCQSxLQUFLLEdBQUdELEtBQTFCO0FBQUEsU0FBMUIsRUFBMkQsQ0FBM0QsQ0FBakM7QUFDQWQsY0FBTSxDQUFDZ0IsNEJBQVAsR0FBc0NDLElBQUksQ0FBQ0MsS0FBTCxDQUFXTix3QkFBd0IsR0FBRyxDQUF0QyxDQUF0QztBQUVBLGVBQU9aLE1BQVA7QUFDRCxPQXZCRDtBQXdCQTFCLGFBQU8sQ0FBQ0ksT0FBRCxDQUFQO0FBQ0QsS0E3RFMsQ0FBVjtBQThERCxHQS9ERCxDQURxQjtBQUFBLENBQXZCOztBQWtFZU4sNkVBQWYiLCJmaWxlIjoiLi9zcmMvZGF0YS9nZXRWYWNjaW5lRGF0YS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBqc29ucEZldGNoIGZyb20gJy4vanNvbnBGZXRjaCc7XG5cbmNvbnN0IGRhdGFVcmwgPVxuICAnaHR0cHM6Ly9kYXRhLm9udGFyaW8uY2EvYXBpLzMvYWN0aW9uL2RhdGFzdG9yZV9zZWFyY2g/cmVzb3VyY2VfaWQ9OGE4OWNhYTktNTExYy00NTY4LWFmODktN2YyMTc0YjQzNzhjJmxpbWl0PTEwMDAwMCc7XG5cbmNvbnN0IGVuc3VyZU51bWJlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcigodmFsdWUgfHwgJzAnKS5yZXBsYWNlKC8sL2csICcnKSk7XG59O1xuXG5jb25zdCBnZXRWYWNjaW5lRGF0YSA9ICgpID0+XG4gIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAganNvbnBGZXRjaChkYXRhVXJsLCAoeyByZXN1bHQgfSkgPT4ge1xuICAgICAgY29uc3QgcmF3UmVjb3JkcyA9IHJlc3VsdC5yZWNvcmRzO1xuICAgICAgcmF3UmVjb3Jkcy5zb3J0KChhLCBiKSA9PiBuZXcgRGF0ZShhLnJlcG9ydF9kYXRlKSAtIG5ldyBEYXRlKGIucmVwb3J0X2RhdGUpKTtcbiAgICAgIGxldCB2YWNjaW5lc19sYXN0N2RheXMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF07XG5cbiAgICAgIC8vIERhdGEgY29tZXMgaW4gd2l0aCBnYXBzIGZvciBzb21lIGRhdGVzLCBzbyBmaWxsIGluIHRoZSBnYXBzIGJ5IHJlcGxpY2F0aW5nIHRoZSBwcmV2aW91cyBkYXRlJ3MgZGF0YVxuICAgICAgY29uc3QgcmVjb3JkcyA9IFtdO1xuICAgICAgZm9yIChsZXQgY3VycmVudFJlY29yZEluZGV4ID0gMTsgY3VycmVudFJlY29yZEluZGV4IDwgcmF3UmVjb3Jkcy5sZW5ndGg7IGN1cnJlbnRSZWNvcmRJbmRleCsrKSB7XG4gICAgICAgIC8vIEJhY2tmaWxsIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgdGhlIGN1cnJlbnQgcmVjb3JkXG4gICAgICAgIGxldCBjdXJyZW50UmVjb3JkID0gcmF3UmVjb3Jkc1tjdXJyZW50UmVjb3JkSW5kZXhdO1xuICAgICAgICBjb25zdCBjdXJSZWNvcmRUaW1lID0gbmV3IERhdGUoY3VycmVudFJlY29yZC5yZXBvcnRfZGF0ZSkuZ2V0VGltZSgpO1xuXG4gICAgICAgIC8vIEFsd2F5cyBhZGQgdGhlIHByZXZpb3VzIHJlY29yZCBpbiB0aGUgb3JpZ2luYWwgZGF0YSBzZXRcbiAgICAgICAgbGV0IHByZXZSZWNvcmQgPSByYXdSZWNvcmRzW2N1cnJlbnRSZWNvcmRJbmRleCAtIDFdO1xuICAgICAgICByZWNvcmRzLnB1c2gocHJldlJlY29yZCk7XG5cbiAgICAgICAgLy8gQ29udGludWUgYWRkaW5nIGNvcGllcyBvZiB0aGUgcHJldmlvdXMgcmVjb3JkLCB1bnRpbCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IHJlY29yZFxuICAgICAgICBsZXQgZGF0ZVRvRmlsbCA9IG5ldyBEYXRlKHByZXZSZWNvcmQucmVwb3J0X2RhdGUpO1xuICAgICAgICBkYXRlVG9GaWxsLnNldERhdGUoZGF0ZVRvRmlsbC5nZXREYXRlKCkgKyAxKTtcblxuICAgICAgICB3aGlsZSAoZGF0ZVRvRmlsbC5nZXRUaW1lKCkgPCBjdXJSZWNvcmRUaW1lKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHJlY29yZCB3aXRoIGEgZGF0ZSB0byBmaWxsXG4gICAgICAgICAgY29uc3QgYmFja2ZpbGxSZWNvcmQgPSBPYmplY3QuYXNzaWduKHt9LCBwcmV2UmVjb3JkLCB7XG4gICAgICAgICAgICByZXBvcnRfZGF0ZTogZGF0ZVRvRmlsbC50b0lTT1N0cmluZygpLnJlcGxhY2UoL1xcLlxcZCtaLywgJycpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlY29yZHMucHVzaChiYWNrZmlsbFJlY29yZCk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGRhdGUgdG8gZmlsbFxuICAgICAgICAgIGRhdGVUb0ZpbGwuc2V0RGF0ZShkYXRlVG9GaWxsLmdldERhdGUoKSArIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgbGFzdCByZWNvcmQsIHdoaWNoIHdhc24ndCBhZGRlZCBieSB0aGUgYWJvdmUgbG9vcFxuICAgICAgcmVjb3Jkcy5wdXNoKHJhd1JlY29yZHNbcmF3UmVjb3Jkcy5sZW5ndGggLSAxXSk7XG5cbiAgICAgIC8vIEJhY2sgdG8geW91ciByZWd1bGFybHkgc2NoZWR1bGVkIGNvZGVcbiAgICAgIHJlY29yZHMubWFwKChyZWNvcmQpID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlcG9ydF9kYXRlLFxuICAgICAgICAgIHRvdGFsX2Rvc2VzX2FkbWluaXN0ZXJlZCxcbiAgICAgICAgICBwcmV2aW91c19kYXlfdG90YWxfZG9zZXNfYWRtaW5pc3RlcmVkLFxuICAgICAgICAgIHRvdGFsX2luZGl2aWR1YWxzX2Z1bGx5X3ZhY2NpbmF0ZWQsXG4gICAgICAgIH0gPSByZWNvcmQ7XG4gICAgICAgIHJlY29yZC5kYXRlX3N0cmluZyA9IG5ldyBEYXRlKHJlcG9ydF9kYXRlKS50b0xvY2FsZVN0cmluZygnZW4tdXMnLCB7XG4gICAgICAgICAgbW9udGg6ICdzaG9ydCcsXG4gICAgICAgICAgZGF5OiAnbnVtZXJpYycsXG4gICAgICAgIH0pO1xuICAgICAgICByZWNvcmQudG90YWxfZG9zZXNfYWRtaW5pc3RlcmVkID0gZW5zdXJlTnVtYmVyKHRvdGFsX2Rvc2VzX2FkbWluaXN0ZXJlZCk7XG4gICAgICAgIHJlY29yZC5wcmV2aW91c19kYXlfdG90YWxfZG9zZXNfYWRtaW5pc3RlcmVkID0gZW5zdXJlTnVtYmVyKHByZXZpb3VzX2RheV90b3RhbF9kb3Nlc19hZG1pbmlzdGVyZWQpO1xuICAgICAgICByZWNvcmQudG90YWxfaW5kaXZpZHVhbHNfZnVsbHlfdmFjY2luYXRlZCA9IGVuc3VyZU51bWJlcih0b3RhbF9pbmRpdmlkdWFsc19mdWxseV92YWNjaW5hdGVkKTtcblxuICAgICAgICByZWNvcmQucHJldmlvdXNfZGF5X3RoaXJkX2Rvc2VzID0gcHJldmlvdXNfZGF5X3RvdGFsX2Rvc2VzX2FkbWluaXN0ZXJlZCAtIGVuc3VyZU51bWJlcihyZWNvcmQucHJldmlvdXNfZGF5X2F0X2xlYXN0X29uZSkgLSBlbnN1cmVOdW1iZXIocmVjb3JkLnByZXZpb3VzX2RheV9mdWxseV92YWNjaW5hdGVkKTtcblxuICAgICAgICB2YWNjaW5lc19sYXN0N2RheXMuc2hpZnQoKTtcbiAgICAgICAgdmFjY2luZXNfbGFzdDdkYXlzLnB1c2gocmVjb3JkLnByZXZpb3VzX2RheV90b3RhbF9kb3Nlc19hZG1pbmlzdGVyZWQpO1xuICAgICAgICBjb25zdCB0b3RhbF92YWNjaW5lc19sYXN0N2RheXMgPSB2YWNjaW5lc19sYXN0N2RheXMucmVkdWNlKCh0b3RhbCwgY2FzZXMpID0+IGNhc2VzICsgdG90YWwsIDApO1xuICAgICAgICByZWNvcmQubmV3X3ZhY2NpbmVzX3JvbGxpbmdfYXZlcmFnZSA9IE1hdGgucm91bmQodG90YWxfdmFjY2luZXNfbGFzdDdkYXlzIC8gNyk7XG5cbiAgICAgICAgcmV0dXJuIHJlY29yZDtcbiAgICAgIH0pO1xuICAgICAgcmVzb2x2ZShyZWNvcmRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IGdldFZhY2NpbmVEYXRhO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/data/getVaccineData.js\n");

/***/ })

})